// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum DataModel_Color: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case red = 0
  case green = 1
  case blue = 2

  public static var max: DataModel_Color { return .blue }
  public static var min: DataModel_Color { return .red }
}


public struct DataModel_Timestamp: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }

  private var _seconds: UInt64
  private var _attoseconds: UInt64

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _seconds = _accessor.readBuffer(of: UInt64.self, at: 0)
    _attoseconds = _accessor.readBuffer(of: UInt64.self, at: 8)
  }

  public init(seconds: UInt64, attoseconds: UInt64) {
    _seconds = seconds
    _attoseconds = attoseconds
  }

  public init() {
    _seconds = 0
    _attoseconds = 0
  }

  public var seconds: UInt64 { _seconds }
  public var attoseconds: UInt64 { _attoseconds }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: DataModel_Timestamp.self)
  }
}

public struct DataModel_Timestamp_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var seconds: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 0) }
  @discardableResult public func mutate(seconds: UInt64) -> Bool { return _accessor.mutate(seconds, index: 0) }
  public var attoseconds: UInt64 { return _accessor.readBuffer(of: UInt64.self, at: 8) }
  @discardableResult public func mutate(attoseconds: UInt64) -> Bool { return _accessor.mutate(attoseconds, index: 8) }
}

public struct DataModel_Vec3: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }

  private var _x: Float32
  private var _y: Float32
  private var _z: Float32

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
    _z = _accessor.readBuffer(of: Float32.self, at: 8)
  }

  public init(x: Float32, y: Float32, z: Float32) {
    _x = x
    _y = y
    _z = z
  }

  public init() {
    _x = 0.0
    _y = 0.0
    _z = 0.0
  }

  public var x: Float32 { _x }
  public var y: Float32 { _y }
  public var z: Float32 { _z }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: DataModel_Vec3.self)
  }
}

public struct DataModel_Vec3_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  @discardableResult public func mutate(x: Float32) -> Bool { return _accessor.mutate(x, index: 0) }
  public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
  @discardableResult public func mutate(y: Float32) -> Bool { return _accessor.mutate(y, index: 4) }
  public var z: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
  @discardableResult public func mutate(z: Float32) -> Bool { return _accessor.mutate(z, index: 8) }
}

public struct DataModel_OpenRequest: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case requestIdentifier = 4
    case clientIdentifier = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var requestIdentifier: UInt64 { let o = _accessor.offset(VTOFFSET.requestIdentifier.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(requestIdentifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.requestIdentifier.v);  return _accessor.mutate(requestIdentifier, index: o) }
  public var clientIdentifier: UInt64? { let o = _accessor.offset(VTOFFSET.clientIdentifier.v); return o == 0 ? nil : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(clientIdentifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.clientIdentifier.v);  return _accessor.mutate(clientIdentifier, index: o) }
  public static func startOpenRequest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(requestIdentifier: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: requestIdentifier, def: 0, at: VTOFFSET.requestIdentifier.p) }
  public static func add(clientIdentifier: UInt64?, _ fbb: inout FlatBufferBuilder) { fbb.add(element: clientIdentifier, at: VTOFFSET.clientIdentifier.p) }
  public static func endOpenRequest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOpenRequest(
    _ fbb: inout FlatBufferBuilder,
    requestIdentifier: UInt64 = 0,
    clientIdentifier: UInt64? = nil
  ) -> Offset {
    let __start = DataModel_OpenRequest.startOpenRequest(&fbb)
    DataModel_OpenRequest.add(requestIdentifier: requestIdentifier, &fbb)
    DataModel_OpenRequest.add(clientIdentifier: clientIdentifier, &fbb)
    return DataModel_OpenRequest.endOpenRequest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.requestIdentifier.p, fieldName: "requestIdentifier", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.clientIdentifier.p, fieldName: "clientIdentifier", required: false, type: UInt64.self)
    _v.finish()
  }
}

public struct DataModel_SnapshotDone: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case streamIdentifier = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var streamIdentifier: UInt64 { let o = _accessor.offset(VTOFFSET.streamIdentifier.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(streamIdentifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.streamIdentifier.v);  return _accessor.mutate(streamIdentifier, index: o) }
  public static func startSnapshotDone(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(streamIdentifier: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: streamIdentifier, def: 0, at: VTOFFSET.streamIdentifier.p) }
  public static func endSnapshotDone(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSnapshotDone(
    _ fbb: inout FlatBufferBuilder,
    streamIdentifier: UInt64 = 0
  ) -> Offset {
    let __start = DataModel_SnapshotDone.startSnapshotDone(&fbb)
    DataModel_SnapshotDone.add(streamIdentifier: streamIdentifier, &fbb)
    return DataModel_SnapshotDone.endSnapshotDone(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.streamIdentifier.p, fieldName: "streamIdentifier", required: false, type: UInt64.self)
    _v.finish()
  }
}

public struct DataModel_Stream: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case streamIdentifier = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var streamIdentifier: UInt64 { let o = _accessor.offset(VTOFFSET.streamIdentifier.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(streamIdentifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.streamIdentifier.v);  return _accessor.mutate(streamIdentifier, index: o) }
  public static func startStream(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(streamIdentifier: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: streamIdentifier, def: 0, at: VTOFFSET.streamIdentifier.p) }
  public static func endStream(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStream(
    _ fbb: inout FlatBufferBuilder,
    streamIdentifier: UInt64 = 0
  ) -> Offset {
    let __start = DataModel_Stream.startStream(&fbb)
    DataModel_Stream.add(streamIdentifier: streamIdentifier, &fbb)
    return DataModel_Stream.endStream(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.streamIdentifier.p, fieldName: "streamIdentifier", required: false, type: UInt64.self)
    _v.finish()
  }
}

public struct DataModel_StreamOpened: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case requestIdentifier = 4
    case streamIdentifier = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var requestIdentifier: UInt64 { let o = _accessor.offset(VTOFFSET.requestIdentifier.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(requestIdentifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.requestIdentifier.v);  return _accessor.mutate(requestIdentifier, index: o) }
  public var streamIdentifier: UInt64? { let o = _accessor.offset(VTOFFSET.streamIdentifier.v); return o == 0 ? nil : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(streamIdentifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.streamIdentifier.v);  return _accessor.mutate(streamIdentifier, index: o) }
  public static func startStreamOpened(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(requestIdentifier: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: requestIdentifier, def: 0, at: VTOFFSET.requestIdentifier.p) }
  public static func add(streamIdentifier: UInt64?, _ fbb: inout FlatBufferBuilder) { fbb.add(element: streamIdentifier, at: VTOFFSET.streamIdentifier.p) }
  public static func endStreamOpened(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStreamOpened(
    _ fbb: inout FlatBufferBuilder,
    requestIdentifier: UInt64 = 0,
    streamIdentifier: UInt64? = nil
  ) -> Offset {
    let __start = DataModel_StreamOpened.startStreamOpened(&fbb)
    DataModel_StreamOpened.add(requestIdentifier: requestIdentifier, &fbb)
    DataModel_StreamOpened.add(streamIdentifier: streamIdentifier, &fbb)
    return DataModel_StreamOpened.endStreamOpened(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.requestIdentifier.p, fieldName: "requestIdentifier", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.streamIdentifier.p, fieldName: "streamIdentifier", required: false, type: UInt64.self)
    _v.finish()
  }
}

public struct DataModel_Monster: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_1_21() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case identifier = 4
    case name = 6
    case pos = 8
    case mana = 10
    case hp = 12
    case color = 14
    case inventory = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var identifier: UInt64 { let o = _accessor.offset(VTOFFSET.identifier.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  @discardableResult public func mutate(identifier: UInt64) -> Bool {let o = _accessor.offset(VTOFFSET.identifier.v);  return _accessor.mutate(identifier, index: o) }
  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public var pos: DataModel_Vec3? { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? nil : _accessor.readBuffer(of: DataModel_Vec3.self, at: o) }
  public var mutablePos: DataModel_Vec3_Mutable? { let o = _accessor.offset(VTOFFSET.pos.v); return o == 0 ? nil : DataModel_Vec3_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var mana: UInt16? { let o = _accessor.offset(VTOFFSET.mana.v); return o == 0 ? nil : _accessor.readBuffer(of: UInt16.self, at: o) }
  @discardableResult public func mutate(mana: UInt16) -> Bool {let o = _accessor.offset(VTOFFSET.mana.v);  return _accessor.mutate(mana, index: o) }
  public var hp: UInt16? { let o = _accessor.offset(VTOFFSET.hp.v); return o == 0 ? nil : _accessor.readBuffer(of: UInt16.self, at: o) }
  @discardableResult public func mutate(hp: UInt16) -> Bool {let o = _accessor.offset(VTOFFSET.hp.v);  return _accessor.mutate(hp, index: o) }
  public var color: DataModel_Color? { let o = _accessor.offset(VTOFFSET.color.v); return o == 0 ? nil : DataModel_Color(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? nil }
  @discardableResult public func mutate(color: DataModel_Color) -> Bool {let o = _accessor.offset(VTOFFSET.color.v);  return _accessor.mutate(color.rawValue, index: o) }
  public var hasInventory: Bool { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? false : true }
  public var inventoryCount: Int32 { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func inventory(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.inventory.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var inventory: [UInt8] { return _accessor.getVector(at: VTOFFSET.inventory.v) ?? [] }
  public func mutate(inventory: UInt8, at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.inventory.v); return _accessor.directMutate(inventory, index: _accessor.vector(at: o) + index * 1) }
  public static func startMonster(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(identifier: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: identifier, def: 0, at: VTOFFSET.identifier.p) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func add(pos: DataModel_Vec3?, _ fbb: inout FlatBufferBuilder) { guard let pos = pos else { return }; fbb.create(struct: pos, position: VTOFFSET.pos.p) }
  public static func add(mana: UInt16?, _ fbb: inout FlatBufferBuilder) { fbb.add(element: mana, at: VTOFFSET.mana.p) }
  public static func add(hp: UInt16?, _ fbb: inout FlatBufferBuilder) { fbb.add(element: hp, at: VTOFFSET.hp.p) }
  public static func add(color: DataModel_Color?, _ fbb: inout FlatBufferBuilder) { fbb.add(element: color?.rawValue, at: VTOFFSET.color.p) }
  public static func addVectorOf(inventory: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: inventory, at: VTOFFSET.inventory.p) }
  public static func endMonster(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMonster(
    _ fbb: inout FlatBufferBuilder,
    identifier: UInt64 = 0,
    nameOffset name: Offset = Offset(),
    pos: DataModel_Vec3? = nil,
    mana: UInt16? = nil,
    hp: UInt16? = nil,
    color: DataModel_Color? = nil,
    inventoryVectorOffset inventory: Offset = Offset()
  ) -> Offset {
    let __start = DataModel_Monster.startMonster(&fbb)
    DataModel_Monster.add(identifier: identifier, &fbb)
    DataModel_Monster.add(name: name, &fbb)
    DataModel_Monster.add(pos: pos, &fbb)
    DataModel_Monster.add(mana: mana, &fbb)
    DataModel_Monster.add(hp: hp, &fbb)
    DataModel_Monster.add(color: color, &fbb)
    DataModel_Monster.addVectorOf(inventory: inventory, &fbb)
    return DataModel_Monster.endMonster(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.identifier.p, fieldName: "identifier", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pos.p, fieldName: "pos", required: false, type: DataModel_Vec3.self)
    try _v.visit(field: VTOFFSET.mana.p, fieldName: "mana", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.hp.p, fieldName: "hp", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.color.p, fieldName: "color", required: false, type: DataModel_Color.self)
    try _v.visit(field: VTOFFSET.inventory.p, fieldName: "inventory", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

